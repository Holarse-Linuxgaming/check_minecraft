#!/usr/bin/env python3

"""check_minecraft: A Nagios3/Icinga2 plugin for monitoring the
status of as Minecraft server."""

__author__      = "Mark Rogaski"
__email__       = "mrogaski@pobox.com"
__copyright__   = "Copyright 2015, Mark Rogaski"
__license__     = "MIT"
__version__     = "0.1.0"

import sys

if sys.version_info[0] < 3:
    print('Python version 3 is required.')
    sys.exit(1)

import argparse
import math
import time
import struct
import socket
import binascii
import json
import nagiosplugin
import logging

_log = logging.getLogger('nagiosplugin')

class MCSession:
    def __init__(self, host, port=25565):
        self.host = host
        self.addr = None
        self.port = port
        self.sock = None

    def connect(self):
        addr_list = socket.getaddrinfo(self.host, self.port,
                                       proto=socket.IPPROTO_TCP)
        err = None
        for af, socktype, proto, cn, sockaddr in addr_list:
            s = None
            try:
                sock = socket.socket(af, socktype, proto)
                sock.connect(sockaddr)
                self.sock = sock
                self.addr = sockaddr[0]
            except OSError as e:
                err = e
                if sock:
                    sock.close()
            else:
                break
        else:
            raise err
        if not addr_list:
            raise RunTimeError('cannot find address for %s' % host)

    @staticmethod
    def encode_varint(k):
        if k < 0:
            raise NotImplementedError('Negative VarInt')
        elif k == 0:
            s = struct.pack('B', 0)
        else:
            n = math.floor(math.log(k, 128)) + 1
            s = b''
            for i in range(n):
                b = k & 0x7f
                if i < n - 1:
                    b = b | 0x80
                s = s + struct.pack('B', b)
                k = k >> 7
        return s

    @staticmethod
    def decode_varint(s):
        n = len(s)
        k = 0
        for i in range(n):
            b = (struct.unpack('B', s[i:i+1]))[0]
            if i < n - 1:
                if b & 0x80:
                    b = b & 0x7f
                else:
                    raise ValueError('Invalid VarInt')
            else:
                if b & 0x80:
                    raise ValueError('Invalid VarInt')
            k = k + (b << (7 * i))
        return k

    def send(self, pid, data=b''):
        payload = self.encode_varint(pid) + data
        pdu = self.encode_varint(len(payload)) + payload
        _log.debug('Tx %d byte(s); length: %d, id: 0x%02X' % (len(pdu), 
                                                             len(payload),
                                                             pid))
        self.sock.send(pdu)

    def recv(self):
        buf = b''
        tlen = 0
        plen = None
        for i in range(5):
            b = self.sock.recv(1)
            if b is not None:
                buf = buf + b
                tlen = tlen + 1
            else:
                raise RunTimeError('Connection read failure.')
            try:
                plen = self.decode_varint(buf)
            except ValueError:
                pass
            else:
                break
        payload = b''
        while plen - len(payload) > 0:
            buf = self.sock.recv(plen - len(payload))
            payload = payload + buf
        tlen = tlen + len(payload)
        pid = (struct.unpack('B', payload[0:1]))[0]
        _log.debug('Rx %d byte(s); length: %d, id: 0x%02X' % (tlen, plen, pid))
        return (pid, payload[1:])

    def ping(self):
        # Handshake
        msg = struct.pack('B', 0x05)
        msg = msg + self.encode_varint(len(self.addr)) + bytes(self.addr,
                                                               'utf-8')
        msg = msg + struct.pack('!HB', self.port, 0x01)
        self.send(0x00, msg)

        # Request
        t = time.time()
        self.send(0x00)

        # Response
        pid, res = self.recv()
        t = time.time() - t
        if pid != 0x00:
            raise RunTimeError('unexpected server response: 0x%02X' % pid)

        # Parse response
        buf = b''
        rlen = None
        for i in range(5):
            buf = buf + res[0:1]
            res = res[1:]
            try:
                rlen = self.decode_varint(buf)
            except ValueError:
                pass
            else:
                break
        data = json.loads(res.decode(encoding='utf-8'))
        return (data['players']['online'], data['players']['max'], t)

    def close(self):
        self.sock.close()
        self.sock = None
        self.addr = None
            
class MCServer(nagiosplugin.Resource):
    def __init__(self, address, port=25565):
        self.address = address
        self.port = port
        self.version = None

    def probe(self):
        session = MCSession(self.address, self.port)
        session.connect()
        pcur, pmax, t = session.ping()
        session.close()
        util = pcur / pmax * 100
        return [nagiosplugin.Metric('online', True, context='status'),
                nagiosplugin.Metric('players', pcur, min=0, max=pmax,
                                    context='slots'),
                nagiosplugin.Metric('utilization', util,
                                    context='utilization', uom='%')]


def main():
    argp = argparse.ArgumentParser(description=__doc__)
    argp.add_argument('address', metavar='ADDRESS',
                      help='hostname or IP address of the server')
    argp.add_argument('-v', '--verbose', action='count', default=0)
    argp.add_argument('-p', '--port', metavar='PORT', default=25565,
                      help='TCP port number of the server')
    argp.add_argument('-w', '--warning', metavar='RANGE', default='75',
                      help='return warning if load is outside RANGE')
    argp.add_argument('-c', '--critical', metavar='RANGE', default='90',
                      help='return critical if load is outside RANGE')
    args = argp.parse_args()
    check = nagiosplugin.Check(
        MCServer(args.address, args.port),
        nagiosplugin.Context('status'),
        nagiosplugin.ScalarContext('slots'),
        nagiosplugin.ScalarContext('utilization', args.warning,
                                   args.critical))
    check.main(args.verbose)

if __name__ == '__main__':
    main()

