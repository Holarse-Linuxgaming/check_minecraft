#!/usr/bin/env python

"""check_minecraft: A Nagios3/Icinga2 plugin for monitoring the
status of as Minecraft server."""

__author__      = "Mark Rogaski"
__email__       = "mrogaski@pobox.com"
__copyright__   = "Copyright 2015, Mark Rogaski"
__license__     = "MIT"
__version__     = "0.1.0"

import argparse
import math
import struct
import socket
import binascii
import nagiosplugin
import logging

_log = logging.getLogger('nagiosplugin')

class MCSession:
    def __init__(self, host, port=25565):
        self.host = host
        self.addr = None
        self.port = port
        self.sock = None

    def connect(self):
        addr_list = socket.getaddrinfo(self.host, self.port,
                                       proto=socket.IPPROTO_TCP)
        err = None
        for af, socktype, proto, cn, sockaddr in addr_list:
            s = None
            try:
                sock = socket.socket(af, socktype, proto)
                sock.connect(sockaddr)
                self.sock = sock
                self.addr = sockaddr[0]
            except OSError as e:
                err = e
                if sock:
                    sock.close()
            else:
                break
        else:
            raise err
        if not addr_list:
            raise RunTimeError('cannot find address for %s' % host)

    @staticmethod
    def encode_varint(k):
        if k < 0:
            raise NotImplementedError('Negative VarInt')
        elif k == 0:
            s = struct.pack('B', 0)
        else:
            n = math.floor(math.log(k, 128)) + 1
            s = b''
            for i in range(n):
                b = k & 0x7f
                if i < n - 1:
                    b = b | 0x80
                s = s + struct.pack('B', b)
                k = k >> 7
        return s

    @staticmethod
    def decode_varint(s):
        n = len(s)
        k = 0
        for i in range(n):
            b = (struct.unpack('B', s[i:i+1]))[0]
            if i < n - 1:
                if b & 0x80:
                    b = b & 0x7f
                else:
                    raise ValueError('Invalid VarInt')
            else:
                if b & 0x80:
                    raise ValueError('Invalid VarInt')
            k = k + (b << (7 * i))
        return k

    def send(self, pid, data=b''):
        pdu = self.encode_varint(pid) + data
        pdu = self.encode_varint(len(pdu)) + pdu
        _log.debug('Tx: %s' % binascii.hexlify(pdu))
        self.sock.send(pdu)

    def recv(self):
        buff = b''
        plen = None
        for i in range(5):
            b = self.sock.recv(1)
            if b is not None:
                _log.debug('Rx: %s', binascii.hexlify(b))
                buff = buff + b
            else:
                raise RunTimeError('Connection read failure.')
            try:
                plen = self.decode_varint(buff)
            except ValueError:
                pass
            else:
                break
        buff = b''
        while plen - len(buff) > 0:
            data = self.sock.recv(plen - len(buff))
            _log.debug('Rx: %s' % binascii.hexlify(data[0:16]))
            buff = buff + data 

    def ping(self):
        # Handshake
        msg = struct.pack('B', 0x05)
        msg = msg + self.encode_varint(len(self.addr)) + bytes(self.addr,
                                                               'utf-8')
        msg = msg + struct.pack('!HB', self.port, 0x01)
        self.send(0x00, msg)

        # Request
        self.send(0x00)

        # Response
        self.recv()

    def close(self):
        self.sock.close()
        self.sock = None
        self.addr = None
            
class MCServer(nagiosplugin.Resource):
    def __init__(self, address, port=25565):
        self.address = address
        self.port = port
        self.version = None

    def probe(self):
        session = MCSession(self.address, self.port)
        session.connect()
        session.ping()
        session.close()

        _log.debug('using dummy data')
        players = 60
        limit = 64
        utilization = players / limit * 100
        return [nagiosplugin.Metric('online', True, context='status'),
                nagiosplugin.Metric('players', players, min=0, max=limit,
                                    context='slots'),
                nagiosplugin.Metric('utilization', utilization,
                                    context='utilization', uom='%')]


def main():
    argp = argparse.ArgumentParser(description=__doc__)
    argp.add_argument('address', metavar='ADDRESS',
                      help='hostname or IP address of the server')
    argp.add_argument('-v', '--verbose', action='count', default=0)
    argp.add_argument('-p', '--port', metavar='PORT', default=25565,
                      help='TCP port number of the server')
    argp.add_argument('-w', '--warning', metavar='RANGE', default='75',
                      help='return warning if load is outside RANGE')
    argp.add_argument('-c', '--critical', metavar='RANGE', default='90',
                      help='return critical if load is outside RANGE')
    args = argp.parse_args()
    check = nagiosplugin.Check(
        MCServer(args.address, args.port),
        nagiosplugin.Context('status'),
        nagiosplugin.ScalarContext('slots'),
        nagiosplugin.ScalarContext('utilization', args.warning,
                                   args.critical))
    check.main(args.verbose)

if __name__ == '__main__':
    main()

